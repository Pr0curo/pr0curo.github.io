<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mein Blog</title>
    <link>https://pr0curo.github.io/</link>
    <description>Recent content on Mein Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language>
    <lastBuildDate>Mon, 28 Feb 2022 21:54:31 +0100</lastBuildDate><atom:link href="https://pr0curo.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CMake &#43; VSCode include Path(s) finden lassen</title>
      <link>https://pr0curo.github.io/posts/cmake-vscode-include_paths_finden_lassen/</link>
      <pubDate>Mon, 28 Feb 2022 21:54:31 +0100</pubDate>
      
      <guid>https://pr0curo.github.io/posts/cmake-vscode-include_paths_finden_lassen/</guid>
      <description>Beim Arbeiten mit VSCode und C++ fällt unweigerlich früher oder später auf, dass viele Header-Datein nicht gefunden werden. Dabei wird, wenn CMake als MetaBuildSystem verwendet wird, die Information ja bereits zusammengetragen.
Bisher war es jedoch schwierig Information mit VSCode so zu teilen, dass nichts händisch nachgetragen werden muss. Zumindest bis ich folgende Frage+Antwort auf stackoverflow fand: https://stackoverflow.com/questions/36122358/visual-studio-code-c-include-path.
Zusammengefasst: in der CmakeLists.txt folgende Option aktivieren
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)) und anschließend im Projektordner unter .</description>
    </item>
    
    <item>
      <title>Live Logfile-View</title>
      <link>https://pr0curo.github.io/posts/live_log_file_view/</link>
      <pubDate>Mon, 28 Feb 2022 19:12:47 +0100</pubDate>
      
      <guid>https://pr0curo.github.io/posts/live_log_file_view/</guid>
      <description>Innerhalb einer Linux/MSys2 Umgebung
tail -f &amp;lt;pfad&amp;gt;
eingeben, um laufend über neue Einträge im Logfile informiert zu werden.</description>
    </item>
    
    <item>
      <title>The worst tool for the job</title>
      <link>https://pr0curo.github.io/posts/worst_tool_for_the_job/</link>
      <pubDate>Mon, 28 Feb 2022 19:01:54 +0100</pubDate>
      
      <guid>https://pr0curo.github.io/posts/worst_tool_for_the_job/</guid>
      <description>Gefunden am 28.07.2020 auf yc
Interessanter Gedankengang: bei neuen Werkzeugen zuerst die günstigste Variante kaufen und nur wenn sich das Werkzeug bewährt und verschleißt oder kaputt geht, auf die teuerste Variante umsteigen[1].
[1] https://www.johndcook.com/blog/2020/07/25/worst-tool-for-the-job/</description>
    </item>
    
    <item>
      <title>Python/Flask Environment</title>
      <link>https://pr0curo.github.io/posts/python_flask_environment/</link>
      <pubDate>Mon, 28 Feb 2022 18:58:13 +0100</pubDate>
      
      <guid>https://pr0curo.github.io/posts/python_flask_environment/</guid>
      <description>Zum erstellen der Environment zum erfolgreichen Python programmieren ist es mittlerweile ein umfangreicher Weg.
Umfänglich beschrieben ist dieser Weg hier: https://cjolowicz.github.io/posts/hypermodern-python-01-setup/ Zum aktuellen Stand gibt es noch keine Veränderungen. Wer Poetry zum handeln der virtuellen Umgebung nicht nutzen möchte kann ohne Probleme zu pipenv greifen.
Unter Pop!_OS muss beachtet werden, dass die pyenv etwas an Vorbereitung benötigt. Die notwendigen Bibliotheken (respektive der Befehl zur Installation dieser ist hier zu finden: https://github.</description>
    </item>
    
    <item>
      <title>Initial_post</title>
      <link>https://pr0curo.github.io/posts/initial_post/</link>
      <pubDate>Mon, 28 Feb 2022 18:41:02 +0100</pubDate>
      
      <guid>https://pr0curo.github.io/posts/initial_post/</guid>
      <description>der erste Eintrag</description>
    </item>
    
  </channel>
</rss>
